<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEON RUSH ‚Äî POLICE CHASE EDITION</title>
    <meta name="description"
        content="NEON RUSH gameplay ‚Äî A 3D cyberpunk endless runner with police chase, power-ups, hacking challenges, and neon visuals. How far can you run?">
    <meta name="theme-color" content="#050505">
    <meta property="og:title" content="NEON RUSH ‚Äî POLICE CHASE EDITION">
    <meta property="og:description"
        content="3D cyberpunk endless runner. Dodge, hack, boost ‚Äî don't let the police catch you!">
    <meta property="og:type" content="website">
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><polygon points='50,5 95,50 50,95 5,50' fill='%2300f2ff'/></svg>">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap"
        rel="stylesheet">
    <link rel="preload" href="music.mp3" as="audio">
    <link rel="preload" href="hit.mp3" as="audio">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #050505;
            font-family: 'Orbitron', sans-serif;
        }

        #ui {
            position: absolute;
            top: 30px;
            left: 30px;
            color: #fff;
            font-size: 32px;
            font-weight: 900;
            letter-spacing: 2px;
            text-shadow: 0 0 15px rgba(0, 255, 255, 0.7);
            pointer-events: none;
            z-index: 5;
        }

        #livesContainer {
            position: absolute;
            top: 30px;
            right: 30px;
            display: flex;
            gap: 10px;
            z-index: 5;
        }

        .heart {
            font-size: 30px;
            color: #ff0055;
            text-shadow: 0 0 10px #ff0055;
            transition: 0.3s;
        }

        .heart.lost {
            opacity: 0.2;
            transform: scale(0.8);
            filter: grayscale(1);
        }

        #policeUI {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff0000;
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            text-shadow: 0 0 10px #ff0000;
            z-index: 5;
        }

        #distBar {
            width: 200px;
            height: 10px;
            background: rgba(255, 0, 0, 0.2);
            border: 1px solid #ff0000;
            margin-top: 5px;
        }

        #distFill {
            width: 100%;
            height: 100%;
            background: #ff0000;
            transition: 0.1s;
        }

        #magnetUI,
        #boostUI,
        #hackTimerUI,
        #antiGravUI {
            position: absolute;
            left: 30px;
            font-size: 18px;
            display: none;
            text-transform: uppercase;
            font-weight: bold;
        }

        #magnetUI {
            top: 120px;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
        }

        #boostUI {
            top: 180px;
            color: #ffd700;
            text-shadow: 0 0 10px #ffd700;
        }

        #hackTimerUI {
            top: 240px;
            color: #aa00ff;
            text-shadow: 0 0 10px #aa00ff;
        }

        #antiGravUI {
            top: 300px;
            color: #ff00ff;
            text-shadow: 0 0 10px #ff00ff;
        }

        /* --- ALPHA STONE CHALLENGE OVERLAY --- */
        #alphaOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: radial-gradient(circle, rgba(0, 0, 0, 0.3) 0%, rgba(0, 0, 0, 0.85) 100%);
            z-index: 3500;
            pointer-events: auto;
        }

        .alpha-panel {
            background: rgba(5, 0, 20, 0.95);
            border: 2px solid;
            border-image: linear-gradient(135deg, #ff00ff, #00f2ff, #ff6600, #00ff88) 1;
            padding: 30px 40px;
            border-radius: 12px;
            text-align: center;
            position: relative;
            overflow: hidden;
            animation: alphaPanelIn 0.4s cubic-bezier(0.16, 1, 0.3, 1);
            max-width: 90vw;
        }

        @keyframes alphaPanelIn {
            from {
                transform: scale(0.3) rotateX(30deg);
                opacity: 0;
            }

            to {
                transform: scale(1) rotateX(0deg);
                opacity: 1;
            }
        }

        .alpha-panel::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(135deg, #ff00ff33, #00f2ff33, #ff660033, #00ff8833);
            z-index: -1;
            filter: blur(20px);
            animation: rainbowShift 2s linear infinite;
        }

        @keyframes rainbowShift {
            0% {
                filter: blur(20px) hue-rotate(0deg);
            }

            100% {
                filter: blur(20px) hue-rotate(360deg);
            }
        }

        .alpha-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            letter-spacing: 4px;
            color: #ff00ff;
            text-shadow: 0 0 15px #ff00ff;
            margin-bottom: 8px;
            text-transform: uppercase;
        }

        .alpha-timer {
            font-family: 'Share Tech Mono', monospace;
            font-size: 13px;
            color: #00f2ff;
            margin-bottom: 15px;
            letter-spacing: 2px;
        }

        .alpha-letters {
            display: flex;
            gap: 12px;
            justify-content: center;
            margin-bottom: 18px;
            flex-wrap: wrap;
        }

        .alpha-letter {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Orbitron', sans-serif;
            font-size: 28px;
            font-weight: 900;
            color: #fff;
            text-shadow: 0 0 20px currentColor;
            border: 2px solid rgba(255, 0, 255, 0.5);
            background: rgba(255, 0, 255, 0.08);
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.16, 1, 0.3, 1);
            user-select: none;
            -webkit-user-select: none;
            position: relative;
        }

        .alpha-letter:hover {
            border-color: #00f2ff;
            background: rgba(0, 242, 255, 0.15);
            transform: translateY(-3px) scale(1.08);
            box-shadow: 0 0 25px rgba(0, 242, 255, 0.4);
        }

        .alpha-letter.correct {
            border-color: #00ff88;
            color: #00ff88;
            background: rgba(0, 255, 136, 0.2);
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.5);
            transform: scale(1.15);
            pointer-events: none;
            animation: letterCorrect 0.3s ease;
        }

        @keyframes letterCorrect {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.3);
            }

            100% {
                transform: scale(1.15);
            }
        }

        .alpha-letter.wrong {
            border-color: #ff003c;
            color: #ff003c;
            background: rgba(255, 0, 60, 0.3);
            animation: letterWrong 0.4s ease;
        }

        @keyframes letterWrong {

            0%,
            100% {
                transform: translateX(0);
            }

            20% {
                transform: translateX(-8px);
            }

            40% {
                transform: translateX(8px);
            }

            60% {
                transform: translateX(-5px);
            }

            80% {
                transform: translateX(5px);
            }
        }

        .alpha-combo {
            font-family: 'Share Tech Mono', monospace;
            font-size: 12px;
            color: #ffd700;
            text-shadow: 0 0 10px #ffd700;
            letter-spacing: 2px;
        }

        .alpha-golden-badge {
            display: inline-block;
            padding: 2px 10px;
            background: linear-gradient(135deg, #ffd700, #ff8c00);
            color: #000;
            font-size: 10px;
            font-weight: 900;
            letter-spacing: 2px;
            border-radius: 3px;
            margin-bottom: 8px;
            animation: goldenPulse 1s ease-in-out infinite;
        }

        @keyframes goldenPulse {

            0%,
            100% {
                box-shadow: 0 0 10px #ffd700;
            }

            50% {
                box-shadow: 0 0 25px #ffd700;
            }
        }

        /* Glitch effect for failure */
        @keyframes alphaGlitch {
            0% {
                transform: translate(0);
                filter: none;
            }

            10% {
                transform: translate(-5px, 3px);
                filter: hue-rotate(90deg);
            }

            20% {
                transform: translate(5px, -3px);
                filter: hue-rotate(180deg);
            }

            30% {
                transform: translate(-3px, -5px);
                filter: hue-rotate(270deg);
            }

            40% {
                transform: translate(3px, 5px);
                filter: none;
            }

            50% {
                transform: translate(0);
            }

            100% {
                transform: translate(0);
                filter: none;
            }
        }

        .glitch-effect {
            animation: alphaGlitch 0.5s ease !important;
        }

        .pwr-bar-bg {
            width: 150px;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            margin-top: 5px;
            border: 1px solid currentColor;
        }

        .pwr-bar-fill {
            height: 100%;
            background: currentColor;
            width: 100%;
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: radial-gradient(circle, rgba(0, 0, 0, 0.4) 0%, rgba(0, 0, 0, 0.9) 100%);
            color: white;
            z-index: 10;
        }

        #flashOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 0, 0, 0.6);
            pointer-events: none;
            opacity: 0;
            z-index: 100;
        }

        .hud-sub {
            font-size: 14px;
            color: #0ff;
            display: block;
            font-family: 'Share Tech Mono', monospace;
        }

        h1 {
            font-size: 90px;
            margin: 0;
            color: #0ff;
            text-shadow: 0 0 30px #0ff;
            font-style: italic;
        }

        .overlay-btns {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 10px;
        }

        button {
            padding: 20px 60px;
            font-size: 24px;
            background: #fff;
            border: none;
            cursor: pointer;
            border-radius: 5px;
            font-weight: bold;
            font-family: 'Orbitron', sans-serif;
            clip-path: polygon(10% 0, 100% 0, 90% 100%, 0% 100%);
            transition: 0.3s;
            pointer-events: auto;
            margin-top: 10px;
        }

        button:hover {
            background: #0ff;
            transform: scale(1.1) skewX(-10deg);
        }

        .btn-menu {
            background: transparent;
            border: 2px solid #0ff;
            color: #0ff;
            font-size: 16px;
            padding: 12px 40px;
            clip-path: polygon(10% 0, 100% 0, 90% 100%, 0% 100%);
        }

        .btn-menu:hover {
            background: #0ff;
            color: #000;
        }

        /* --- CHALLENGE UI --- */
        #hackOverlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #aa00ff;
            padding: 40px;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 10px;
            box-shadow: 0 0 50px #aa00ff;
            z-index: 3000;
        }

        #hackTitle {
            color: #aa00ff;
            font-size: 18px;
            margin-bottom: 20px;
            letter-spacing: 3px;
            text-transform: uppercase;
            font-weight: bold;
        }

        #hackSymbols {
            color: #555;
            font-size: 64px;
            font-weight: bold;
            letter-spacing: 25px;
            display: flex;
            gap: 15px;
        }

        #hackSymbols span {
            transition: all 0.2s;
        }

        #pauseOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.7);
            z-index: 2000;
        }

        .pause-box {
            padding: 40px;
            border: 3px solid #00ffff;
            background: rgba(0, 10, 20, 0.9);
            box-shadow: 0 0 40px #00ffff;
            text-align: center;
            border-radius: 15px;
        }

        .pause-title {
            color: #00ffff;
            font-size: 48px;
            margin-bottom: 30px;
            text-shadow: 0 0 15px #00ffff;
            letter-spacing: 5px;
        }

        .btn-resume {
            background: #00ffff;
            color: #000;
        }

        .btn-restart {
            background: #ff0055;
            color: #fff;
            border: 2px solid #ff0055;
            margin-left: 10px;
        }

        /* --- MOBILE TOUCH CONTROLS --- */
        #mobileControls {
            position: absolute;
            bottom: 80px;
            left: 0;
            width: 100%;
            display: none;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 50;
            pointer-events: none;
        }

        .touch-btn {
            width: 70px;
            height: 70px;
            border: 2px solid rgba(0, 242, 255, 0.4);
            border-radius: 50%;
            background: rgba(0, 242, 255, 0.08);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            color: rgba(0, 242, 255, 0.6);
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
            transition: all 0.15s;
        }

        .touch-btn:active {
            background: rgba(0, 242, 255, 0.3);
            border-color: rgba(0, 242, 255, 0.8);
            transform: scale(0.9);
        }

        .touch-center {
            display: flex;
            gap: 15px;
        }

        /* --- RESPONSIVE --- */
        @media (max-width: 768px) {
            #ui {
                font-size: 22px;
                top: 15px;
                left: 15px;
            }

            #livesContainer {
                top: 15px;
                right: 15px;
            }

            .heart {
                font-size: 22px;
            }

            h1 {
                font-size: 50px;
            }

            #magnetUI,
            #boostUI,
            #hackTimerUI,
            #antiGravUI {
                font-size: 14px;
                left: 15px;
            }

            #magnetUI {
                top: 90px;
            }

            #boostUI {
                top: 130px;
            }

            #hackTimerUI {
                top: 170px;
            }

            #antiGravUI {
                top: 210px;
            }

            .pwr-bar-bg {
                width: 100px;
            }

            #policeUI {
                font-size: 14px;
                bottom: 100px;
            }

            #distBar {
                width: 140px;
            }

            button {
                padding: 15px 40px;
                font-size: 18px;
            }

            #hackSymbols {
                font-size: 40px;
                letter-spacing: 12px;
                gap: 8px;
            }

            #hackOverlay {
                padding: 25px;
            }

            .alpha-letter {
                width: 50px;
                height: 50px;
                font-size: 22px;
            }

            .alpha-panel {
                padding: 20px 25px;
            }

            #mobileControls {
                display: flex;
            }
        }

        @media (max-width: 480px) {
            #ui {
                font-size: 18px;
                top: 10px;
                left: 10px;
            }

            h1 {
                font-size: 36px;
            }

            button {
                padding: 12px 30px;
                font-size: 16px;
            }

            .touch-btn {
                width: 55px;
                height: 55px;
                font-size: 22px;
            }
        }
    </style>
</head>

<body>

    <div id="flashOverlay"></div>

    <div id="ui">
        <span class="hud-sub">SYSTEM ACTIVE</span>
        SCORE: <span id="scoreVal">00000</span>
        <div style="font-size: 18px; color: #ffd700;">COINS: <span id="coinVal">0</span></div>
    </div>

    <div id="pauseOverlay">
        <div class="pause-box">
            <div class="pause-title">GAME PAUSED</div>
            <button class="btn-resume" onclick="togglePause()">RESUME</button>
            <button class="btn-restart" onclick="restartGame()">RESTART</button>
        </div>
    </div>

    <div id="hackOverlay">
        <div id="hackTitle">NEURAL BYPASS INITIALIZED</div>
        <div id="hackSymbols"></div>
    </div>

    <div id="hackTimerUI">
        üì° LANE HACKED: <span id="hTime">4.0</span>s
        <div class="pwr-bar-bg">
            <div id="hackBarFill" class="pwr-bar-fill"></div>
        </div>
    </div>

    <div id="policeUI">
        POLICE DISTANCE
        <div id="distBar">
            <div id="distFill"></div>
        </div>
    </div>

    <div id="magnetUI">
        üß≤ MAGNET: <span id="magTime">5.0</span>s
        <div class="pwr-bar-bg">
            <div id="magBarFill" class="pwr-bar-fill"></div>
        </div>
    </div>
    <div id="boostUI">
        ‚ö° NITRO: <span id="boostTime">4.0</span>s
        <div class="pwr-bar-bg">
            <div id="boostBarFill" class="pwr-bar-fill"></div>
        </div>
    </div>

    <div id="antiGravUI">
        üåÄ ANTI-GRAV: <span id="agTime">6.0</span>s
        <div class="pwr-bar-bg">
            <div id="agBarFill" class="pwr-bar-fill"></div>
        </div>
    </div>

    <!-- Alpha Stone Challenge Overlay -->
    <div id="alphaOverlay">
        <div class="alpha-panel" id="alphaPanel">
            <div id="alphaGoldenBadge" class="alpha-golden-badge" style="display:none">‚òÖ GOLDEN STONE ‚òÖ</div>
            <div class="alpha-title">ANTI-GRAVITY SEQUENCE</div>
            <div class="alpha-timer">TIME: <span id="alphaTimer">5.00</span>s</div>
            <div class="alpha-letters" id="alphaLetters"></div>
            <div class="alpha-combo" id="alphaCombo"></div>
        </div>
    </div>

    <div id="livesContainer">
        <span id="h1" class="heart">‚ù§</span>
        <span id="h2" class="heart">‚ù§</span>
        <span id="h3" class="heart">‚ù§</span>
    </div>

    <!-- Mobile Touch Controls -->
    <div id="mobileControls">
        <div class="touch-btn" id="touchLeft" ontouchstart="handleTouch('left')">‚óÄ</div>
        <div class="touch-center">
            <div class="touch-btn" id="touchJump" ontouchstart="handleTouch('jump')">‚ñ≤</div>
        </div>
        <div class="touch-btn" id="touchRight" ontouchstart="handleTouch('right')">‚ñ∂</div>
    </div>

    <div id="overlay">
        <h1 id="titleText">NEON RUSH</h1>
        <p style="font-family: 'Share Tech Mono', monospace;">POLICE CHASE: Don't let them catch you!</p>
        <div class="overlay-btns">
            <button onclick="startGame()">START RUN</button>
            <button class="btn-menu" onclick="goHome()">‚óÇ MENU</button>
        </div>
    </div>

    <audio id="bgMusic" loop>
        <source src="music.mp3" type="audio/mpeg">
    </audio>
    <audio id="hitSound">
        <source src="hit.mp3" type="audio/mpeg">
    </audio>

    <script>
        const CONFIG = {
            laneWidth: 3.5,
            baseSpeed: 0.4,
            maxSpeed: 1.2,
            acceleration: 0.00005,
            jumpGravity: 0.008,
            jumpForce: 0.22,
            cameraLerp: 0.08,
            fovBase: 65,
            fovBoost: 90,
            cameraLookLerp: 0.1,
            magnetDuration: 8000,
            boostDuration: 4000,
            boostMultiplier: 2.5,
            magnetRange: 15,
            policeMaxDist: 15,
            policeMinDist: 0.5,
            policeRecoveryRate: 0.01,
            policePenalty: 4.5
        };

        let scene, camera, renderer, player, clock, playerShadow, magnetAura, boostWind;
        let police, policeSirenL, policeSirenR;
        let policeDistance = CONFIG.policeMaxDist;
        let obstacles = [], coins = [], magnets = [], boosts = [], tracks = [], particles = [], speedLines = [];
        let lane = 1;
        let isJumping = false;
        let velocityY = 0;
        let gameScore = 0, coinsTotal = 0, active = false;
        let targetX = 0;
        let frameCount = 0;
        let cameraTarget = new THREE.Vector3(0, 2, 0);
        let playerLives = 3;
        let isInvincible = false;
        let magnetActive = false;
        let magnetTimer = 0;
        let boostActive = false;
        let boostTimer = 0;
        let shakeOffsetX = 0, shakeOffsetY = 0;
        let playerTrail;
        const trailPoints = [];
        const MAX_TRAIL_LENGTH = 30;
        let lightBeams = [];

        // --- HACK SYSTEMS ---
        let hackChips = [];
        let hackedLane = -1;
        let hackTimer = 0;
        let hackVisualPlane;

        // --- CHALLENGE STATE ---
        let isPaused = false;
        let hackActive = false;
        let hackInputIndex = 0;
        let hackTimeLimit = 4000;
        let hackTimeRemaining = 0;
        let currentHackSequence = [];
        const HACK_SYMBOLS_MAP = { "ArrowLeft": "‚Üê", "ArrowUp": "‚Üë", "ArrowRight": "‚Üí", "ArrowDown": "‚Üì" };

        // --- ANTI-GRAVITY ALPHA STONE SYSTEM ---
        let alphaStones = [];
        let alphaActive = false; // challenge UI active
        let alphaTimeRemaining = 0;
        const ALPHA_TIME_LIMIT = 8000;
        let alphaCorrectOrder = [];
        let alphaClickIndex = 0;
        let alphaIsGolden = false;

        // Anti-gravity mode state
        let antiGravActive = false;
        let antiGravTimer = 0;
        let antiGravDuration = 6000;
        let antiGravTrailParticles = [];
        let antiGravAura = null;

        // Combo & difficulty
        let alphaComboCount = 0;
        let alphaSuccessCount = 0;
        const ALPHA_BASE_LETTERS = 4;

        // Speed multiplier for slow-motion
        let slowMotionFactor = 1.0;

        // --- MOBILE TOUCH ---
        let touchStartX = 0;
        let touchStartY = 0;

        function goHome() {
            window.location.href = 'index.html';
        }

        function handleTouch(action) {
            if (!active || isPaused) return;
            if (action === 'left' && lane > 0) { lane--; targetX = (lane - 1) * CONFIG.laneWidth; }
            if (action === 'right' && lane < 2) { lane++; targetX = (lane - 1) * CONFIG.laneWidth; }
            if (action === 'jump' && !isJumping) { isJumping = true; velocityY = CONFIG.jumpForce; }
        }

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 10, 120);
            camera = new THREE.PerspectiveCamera(CONFIG.fovBase, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 6, 12);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);
            const ambient = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambient);

            const hackGeo = new THREE.PlaneGeometry(CONFIG.laneWidth, 200);
            const hackMat = new THREE.MeshBasicMaterial({
                color: 0xaa00ff, transparent: true, opacity: 0,
                side: THREE.DoubleSide, blending: THREE.AdditiveBlending
            });
            hackVisualPlane = new THREE.Mesh(hackGeo, hackMat);
            hackVisualPlane.rotation.x = -Math.PI / 2;
            hackVisualPlane.position.y = 0.05;
            scene.add(hackVisualPlane);

            createBackgroundLights();
            createPlayer();
            createBoostWind();
            createAntiGravAura();
            createPolice();
            createWorld();
            createTrail();
            clock = new THREE.Clock();

            // Detect mobile
            if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
                document.getElementById('mobileControls').style.display = 'flex';
            }

            animate();
        }

        // --- ANTI-GRAVITY AURA ---
        function createAntiGravAura() {
            const geo = new THREE.TorusGeometry(1.2, 0.08, 8, 32);
            const mat = new THREE.MeshBasicMaterial({
                color: 0xff00ff,
                transparent: true,
                opacity: 0,
                blending: THREE.AdditiveBlending
            });
            antiGravAura = new THREE.Mesh(geo, mat);
            antiGravAura.rotation.x = Math.PI / 2;
            player.add(antiGravAura);
        }

        // --- CREATE BOOST WIND EFFECT ---
        function createBoostWind() {
            const windGeo = new THREE.CylinderGeometry(0.8, 1.5, 3, 8, 1, true);
            const windMat = new THREE.MeshBasicMaterial({
                color: 0xffaa00,
                transparent: true,
                opacity: 0,
                wireframe: true,
                blending: THREE.AdditiveBlending
            });
            boostWind = new THREE.Mesh(windGeo, windMat);
            boostWind.position.y = 1.4;
            boostWind.rotation.x = Math.PI / 2;
            player.add(boostWind);
        }

        function togglePause() {
            if (!active || hackActive) return;
            isPaused = !isPaused;
            const menu = document.getElementById('pauseOverlay');
            const bgMusic = document.getElementById('bgMusic');
            if (isPaused) { menu.style.display = 'flex'; bgMusic.pause(); }
            else { menu.style.display = 'none'; bgMusic.play(); }
        }

        function restartGame() {
            isPaused = false;
            hackActive = false;
            document.getElementById('pauseOverlay').style.display = 'none';
            document.getElementById('hackOverlay').style.display = 'none';
            startGame();
        }

        // --- CHALLENGE LOGIC ---
        function startHackChallenge() {
            isPaused = true;
            hackActive = true;
            hackInputIndex = 0;
            hackTimeRemaining = hackTimeLimit;
            document.getElementById('bgMusic').pause();

            const keys = ["ArrowLeft", "ArrowUp", "ArrowRight", "ArrowDown"];
            currentHackSequence = [];
            let displayHTML = "";

            for (let i = 0; i < 4; i++) {
                let key = keys[Math.floor(Math.random() * 4)];
                currentHackSequence.push(key);
                displayHTML += `<span id="hchar${i}">${HACK_SYMBOLS_MAP[key]}</span>`;
            }

            const overlay = document.getElementById('hackOverlay');
            document.getElementById('hackSymbols').innerHTML = displayHTML;
            overlay.style.display = 'flex';
        }

        function handleHackInput(key) {
            if (!hackActive) return;
            if (key === currentHackSequence[hackInputIndex]) {
                document.getElementById(`hchar${hackInputIndex}`).style.color = "#00ff00";
                document.getElementById(`hchar${hackInputIndex}`).style.textShadow = "0 0 20px #00ff00";
                hackInputIndex++;
                if (hackInputIndex >= currentHackSequence.length) completeHackSuccess();
            } else {
                completeHackFailure();
            }
        }

        function completeHackSuccess() {
            hackActive = false;
            isPaused = false;
            document.getElementById('hackOverlay').style.display = 'none';
            document.getElementById('bgMusic').play();
            activateLaneHack();
            createBurst(player.position, 0xaa00ff);
        }

        function completeHackFailure() {
            hackActive = false;
            isPaused = false;
            document.getElementById('hackOverlay').style.display = 'none';
            document.getElementById('bgMusic').play();
            policeDistance -= (CONFIG.policePenalty * 2);
            if (policeDistance < CONFIG.policeMinDist) policeDistance = CONFIG.policeMinDist;
            const flash = document.getElementById('flashOverlay');
            flash.style.background = "rgba(255, 0, 0, 0.8)";
            gsap.to(flash, { opacity: 1, duration: 0.1, onComplete: () => gsap.to(flash, { opacity: 0, duration: 0.6 }) });
            shakeCamera(1.5);
        }

        function createBackgroundLights() {
            const beamCount = 4;
            for (let i = 0; i < beamCount; i++) {
                const group = new THREE.Group();
                const width = 15 + Math.random() * 20;
                const height = 150;
                const geo = new THREE.PlaneGeometry(width, height);
                const mat = new THREE.MeshBasicMaterial({
                    color: i % 2 === 0 ? 0x00ffff : 0xaa00ff,
                    transparent: true, opacity: 0.03 + (Math.random() * 0.04),
                    side: THREE.DoubleSide, blending: THREE.AdditiveBlending
                });
                const beam = new THREE.Mesh(geo, mat);
                group.add(beam);
                group.position.set((Math.random() - 0.5) * 100, 20, -80 - (Math.random() * 40));
                group.rotation.z = (Math.random() - 0.5) * 0.5;
                group.rotation.y = (Math.random() - 0.5) * 0.5;
                group.userData = { speed: 0.002 + (Math.random() * 0.005), range: 40 + Math.random() * 40, baseX: group.position.x };
                scene.add(group); lightBeams.push(group);
            }
        }

        function updateBackgroundLights() {
            const time = Date.now() * 0.001;
            lightBeams.forEach((beam) => {
                beam.position.x = beam.userData.baseX + Math.sin(time * beam.userData.speed * 10) * beam.userData.range;
                beam.rotation.z += Math.sin(time * 0.5) * 0.0001;
                if (active && !isPaused) {
                    beam.position.z += (boostActive ? CONFIG.baseSpeed * CONFIG.boostMultiplier : CONFIG.baseSpeed) * 0.8;
                    if (beam.position.z > 20) beam.position.z = -120;
                }
            });
        }

        function createPolice() {
            police = new THREE.Group();
            const bodyGeo = new THREE.BoxGeometry(1.2, 0.8, 2);
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            police.add(body);
            const sirenGeo = new THREE.BoxGeometry(0.4, 0.1, 0.2);
            policeSirenL = new THREE.Mesh(sirenGeo, new THREE.MeshBasicMaterial({ color: 0xff0000 }));
            policeSirenR = new THREE.Mesh(sirenGeo, new THREE.MeshBasicMaterial({ color: 0x0000ff }));
            policeSirenL.position.set(-0.3, 0.45, 0);
            policeSirenR.position.set(0.3, 0.45, 0);
            police.add(policeSirenL, policeSirenR);
            const headGeo = new THREE.CircleGeometry(0.2, 16);
            const headMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const h1 = new THREE.Mesh(headGeo, headMat);
            const h2 = new THREE.Mesh(headGeo, headMat);
            h1.position.set(-0.4, 0, -1.01); h1.rotation.y = Math.PI;
            h2.position.set(0.4, 0, -1.01); h2.rotation.y = Math.PI;
            police.add(h1, h2);
            police.position.z = 10;
            scene.add(police);
        }

        function createTrail() {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(MAX_TRAIL_LENGTH * 3);
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const material = new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.6 });
            playerTrail = new THREE.Line(geometry, material);
            playerTrail.frustumCulled = false;
            scene.add(playerTrail);
        }

        function updateTrail() {
            trailPoints.unshift(new THREE.Vector3(player.position.x, player.position.y - 0.5, player.position.z));
            if (trailPoints.length > MAX_TRAIL_LENGTH) trailPoints.pop();
            const positions = playerTrail.geometry.attributes.position.array;
            const currentSpeed = boostActive ? CONFIG.baseSpeed * CONFIG.boostMultiplier : CONFIG.baseSpeed;
            for (let i = 0; i < trailPoints.length; i++) {
                trailPoints[i].z += currentSpeed;
                positions[i * 3] = trailPoints[i].x;
                positions[i * 3 + 1] = trailPoints[i].y;
                positions[i * 3 + 2] = trailPoints[i].z;
            }
            playerTrail.geometry.attributes.position.needsUpdate = true;
        }

        function createPlayer() {
            player = new THREE.Group();

            const armorMat = new THREE.MeshStandardMaterial({
                color: 0x1a1a1a,
                roughness: 0.05,
                metalness: 0.9,
                emissive: 0x002222,
            });

            const bodyLineMat = new THREE.MeshLambertMaterial({
                color: 0xff6600,
                emissive: 0xff6600,
                emissiveIntensity: 3
            });

            // --- TORSO ---
            const torso = new THREE.Group();
            const chestGeo = new THREE.BoxGeometry(0.7, 0.8, 0.5);
            const chest = new THREE.Mesh(chestGeo, armorMat);
            chest.castShadow = true;

            const coreGeo = new THREE.SphereGeometry(0.18, 8, 8);
            player.coreLight = new THREE.Mesh(coreGeo, bodyLineMat);
            player.coreLight.position.set(0, 0.1, 0.26);
            torso.add(chest, player.coreLight);
            player.add(torso);

            // --- HEAD & VISOR ---
            const headGroup = new THREE.Group();
            const helmetGeo = new THREE.BoxGeometry(0.45, 0.45, 0.45);
            const helmet = new THREE.Mesh(helmetGeo, armorMat);

            const visorGeo = new THREE.BoxGeometry(0.5, 0.12, 0.35);
            const visor = new THREE.Mesh(visorGeo, bodyLineMat);
            visor.position.set(0, 0.05, 0.15);

            headGroup.add(helmet, visor);
            headGroup.position.y = 0.65;
            player.add(headGroup);

            // --- LIMBS ---
            const legGeo = new THREE.BoxGeometry(0.22, 0.7, 0.22);
            player.leftLeg = new THREE.Mesh(legGeo, armorMat);
            player.rightLeg = new THREE.Mesh(legGeo, armorMat);

            const bootGeo = new THREE.BoxGeometry(0.25, 0.15, 0.25);
            const bootL = new THREE.Mesh(bootGeo, bodyLineMat);
            const bootR = new THREE.Mesh(bootGeo, bodyLineMat);
            bootL.position.y = -0.3;
            bootR.position.y = -0.3;
            player.leftLeg.add(bootL);
            player.rightLeg.add(bootR);

            player.leftLeg.position.set(-0.22, -0.6, 0);
            player.rightLeg.position.set(0.22, -0.6, 0);
            player.add(player.leftLeg, player.rightLeg);

            // --- ARMS ---
            const armGeo = new THREE.BoxGeometry(0.18, 0.6, 0.18);
            player.leftArm = new THREE.Mesh(armGeo, armorMat);
            player.rightArm = new THREE.Mesh(armGeo, armorMat);
            player.leftArm.position.set(-0.45, 0.1, 0);
            player.rightArm.position.set(0.45, 0.1, 0);
            player.add(player.leftArm, player.rightArm);

            // --- NEON UNDER-GLOW ---
            const glowGeo = new THREE.PlaneGeometry(1.5, 1.5);
            const glowMat = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.3,
                map: new THREE.TextureLoader().load('https://threejs.org/examples/textures/lensflare/lensflare0.png')
            });
            const underGlow = new THREE.Mesh(glowGeo, glowMat);
            underGlow.rotation.x = -Math.PI / 2;
            underGlow.position.y = -1.35;
            player.add(underGlow);

            // --- AURA ---
            const auraGeo = new THREE.IcosahedronGeometry(1.6, 1);
            const auraMat = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.1,
                wireframe: true
            });
            magnetAura = new THREE.Mesh(auraGeo, auraMat);
            player.add(magnetAura);

            // --- INITIAL STATE ---
            player.position.y = 1.4;
            scene.add(player);

            const shadowGeo = new THREE.CircleGeometry(0.7, 32);
            const shadowMat = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.2,
                depthWrite: false
            });
            playerShadow = new THREE.Mesh(shadowGeo, shadowMat);
            playerShadow.rotation.x = -Math.PI / 2;
            playerShadow.position.y = 0.06;
            scene.add(playerShadow);

            // --- ANIMATION UPDATE LOGIC ---
            player.userData.updateAnimation = function (frameCount, currentSpeed, isJumping) {
                const breathe = Math.sin(frameCount * 0.05) * 0.5 + 0.5;
                player.coreLight.material.emissiveIntensity = 2 + breathe * 3;
                underGlow.material.opacity = 0.2 + (breathe * 0.2);

                magnetAura.rotation.y += 0.02;
                magnetAura.rotation.z += 0.01;

                if (!isJumping) {
                    const walkSpeed = frameCount * (currentSpeed * 0.5);
                    player.position.y = 1.4 + Math.abs(Math.cos(walkSpeed)) * 0.15;
                    torso.rotation.x = 0.2 + (currentSpeed * 0.1);
                }
            };
        }

        function createWorld() {
            for (let i = 0; i < 15; i++) { spawnSegment(-i * 10); }
        }

        function spawnSegment(z) {
            const group = new THREE.Group();
            const geo = new THREE.PlaneGeometry(12, 10);
            const mat = new THREE.MeshStandardMaterial({ color: 0x111111 });
            const plane = new THREE.Mesh(geo, mat);
            plane.rotation.x = -Math.PI / 2;
            group.add(plane);
            const railGeo = new THREE.BoxGeometry(0.1, 0.1, 10);
            const railMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
            [-3.5, -1.2, 1.2, 3.5].forEach(x => {
                const r = new THREE.Mesh(railGeo, railMat);
                r.position.set(x, 0.05, 0);
                group.add(r);
            });
            group.position.z = z;
            scene.add(group);
            tracks.push(group);
        }

        function spawnSpeedLine() {
            if (speedLines.length > 50) return;

            const length = 5 + Math.random() * 5;
            const geo = new THREE.BoxGeometry(0.02, 0.02, length);
            const color = boostActive ? 0xffaa00 : 0x00ffff;
            const mat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.3 + Math.random() * 0.4 });
            const line = new THREE.Mesh(geo, mat);
            const angle = Math.random() * Math.PI * 2;
            const radius = 6 + Math.random() * 12;
            line.position.set(Math.cos(angle) * radius, Math.sin(angle) * radius + 4, -120);
            scene.add(line);
            speedLines.push(line);
        }

        function createBurst(pos, color) {
            if (particles.length > 200) return;
            for (let i = 0; i < 12; i++) {
                const p = new THREE.Mesh(new THREE.SphereGeometry(0.1), new THREE.MeshBasicMaterial({ color: color, transparent: true }));
                p.position.copy(pos);
                p.vel = new THREE.Vector3((Math.random() - 0.5) * 0.3, (Math.random() - 0.2) * 0.3, (Math.random() - 0.5) * 0.3);
                p.life = 1.0; p.decay = 0.01 + Math.random() * 0.02;
                scene.add(p);
                particles.push(p);
            }
        }

        function activateBoost() {
            boostActive = true;
            boostTimer = CONFIG.boostDuration;
            document.getElementById('boostUI').style.display = 'block';
            gsap.to(camera, { fov: CONFIG.fovBoost, duration: 0.5, onUpdate: () => camera.updateProjectionMatrix() });
            gsap.to(boostWind.material, { opacity: 0.4, duration: 0.3 });
            const flash = document.getElementById('flashOverlay');
            flash.style.background = "rgba(255, 215, 0, 0.4)";
            gsap.to(flash, { opacity: 1, duration: 0.1, onComplete: () => gsap.to(flash, { opacity: 0, duration: 0.5 }) });
            createBurst(player.position, 0xffaa00);
        }

        function deactivateBoost() {
            boostActive = false;
            document.getElementById('boostUI').style.display = 'none';
            gsap.to(camera, { fov: CONFIG.fovBase, duration: 0.8, onUpdate: () => camera.updateProjectionMatrix() });
            gsap.to(boostWind.material, { opacity: 0, duration: 0.5 });
        }

        function activateMagnet() {
            magnetActive = true;
            magnetTimer = CONFIG.magnetDuration;
            document.getElementById('magnetUI').style.display = 'block';
            gsap.to(magnetAura.material, { opacity: 0.3, duration: 0.5 });
            createBurst(player.position, 0x00ffff);
        }

        function activateLaneHack() {
            hackedLane = Math.floor(Math.random() * 3);
            hackTimer = 4000;
            document.getElementById('hackTimerUI').style.display = 'block';
            hackVisualPlane.position.x = (hackedLane - 1) * CONFIG.laneWidth;
            gsap.to(hackVisualPlane.material, { opacity: 0.4, duration: 0.2 });
            for (let i = obstacles.length - 1; i >= 0; i--) {
                if (obstacles[i].lane === hackedLane) {
                    createBurst(obstacles[i].position, 0xaa00ff);
                    scene.remove(obstacles[i]);
                    obstacles.splice(i, 1);
                }
            }
        }

        function update() {
            if (hackActive) {
                hackTimeRemaining -= 16.6;
                document.getElementById('hackTitle').innerText = "SYSTEM BYPASS: " + (hackTimeRemaining / 1000).toFixed(2) + "s";
                if (hackTimeRemaining <= 0) completeHackFailure();
            }

            // Alpha stone challenge timer
            if (alphaActive) {
                alphaTimeRemaining -= 16.6;
                document.getElementById('alphaTimer').innerText = Math.max(0, (alphaTimeRemaining / 1000)).toFixed(2);
                if (alphaTimeRemaining <= 0) completeAlphaFailure();
            }

            if (isPaused) return;

            updateBackgroundLights();
            if (!active) return;
            frameCount++;

            // Apply slow motion factor
            const dtFactor = slowMotionFactor;

            // Anti-gravity mode update
            if (antiGravActive) {
                antiGravTimer -= 16.6;
                const agUI = document.getElementById('antiGravUI');
                document.getElementById('agTime').innerText = Math.max(0, (antiGravTimer / 1000)).toFixed(1);
                document.getElementById('agBarFill').style.width = (antiGravTimer / antiGravDuration) * 100 + "%";
                antiGravAura.rotation.z += 0.08;
                antiGravAura.rotation.x = Math.PI / 2 + Math.sin(frameCount * 0.1) * 0.3;

                // Rainbow trail particles
                if (frameCount % 3 === 0) spawnAntiGravTrailParticle();
                updateAntiGravTrail();

                if (antiGravTimer <= 0) deactivateAntiGrav();
            }

            if (hackTimer > 0) {
                hackTimer -= 16.6;
                document.getElementById('hTime').innerText = Math.max(0, (hackTimer / 1000)).toFixed(1);
                document.getElementById('hackBarFill').style.width = (hackTimer / 4000) * 100 + "%";
                if (hackTimer <= 0) {
                    hackedLane = -1;
                    document.getElementById('hackTimerUI').style.display = 'none';
                    gsap.to(hackVisualPlane.material, { opacity: 0, duration: 0.5 });
                }
            }

            if (isJumping) {
                player.position.y += velocityY;
                velocityY -= CONFIG.jumpGravity * (antiGravActive ? 0.5 : 1); // lower gravity in anti-grav
                const groundY = antiGravActive ? 1.8 : 1.4; // float higher in anti-grav
                if (player.position.y <= groundY) {
                    player.position.y = groundY;
                    isJumping = false; velocityY = 0;
                    shakeCamera(0.1);
                }
            }

            let currentSpeed = CONFIG.baseSpeed * dtFactor;
            if (antiGravActive) currentSpeed *= 0.6; // obstacles move slower in anti-grav
            if (boostActive) {
                currentSpeed *= CONFIG.boostMultiplier;
                boostTimer -= 16.6;
                document.getElementById('boostTime').innerText = Math.max(0, (boostTimer / 1000)).toFixed(1);
                document.getElementById('boostBarFill').style.width = (boostTimer / CONFIG.boostDuration) * 100 + "%";
                boostWind.rotation.y += 0.2;
                policeDistance = Math.min(CONFIG.policeMaxDist, policeDistance + 0.05);
                if (boostTimer <= 0) deactivateBoost();
            }

            if (CONFIG.baseSpeed < CONFIG.maxSpeed) CONFIG.baseSpeed += CONFIG.acceleration;
            updateTrail();
            if (frameCount % Math.max(1, Math.floor(12 - currentSpeed * 8)) === 0) spawnSpeedLine();

            policeDistance = Math.min(CONFIG.policeMaxDist, policeDistance + CONFIG.policeRecoveryRate);
            police.position.z = player.position.z + policeDistance;
            police.position.x = THREE.MathUtils.lerp(police.position.x, player.position.x, 0.05);
            if (frameCount % 10 === 0) {
                policeSirenL.material.opacity = policeSirenL.material.opacity === 1 ? 0.2 : 1;
                policeSirenR.material.opacity = policeSirenL.material.opacity === 1 ? 0.2 : 1;
            }

            document.getElementById('distFill').style.width = (policeDistance / CONFIG.policeMaxDist) * 100 + "%";
            if (policeDistance < 1.5) handleCollision("BUSTED!");

            if (magnetActive) {
                magnetTimer -= 16.6;
                document.getElementById('magTime').innerText = Math.max(0, (magnetTimer / 1000)).toFixed(1);
                document.getElementById('magBarFill').style.width = (magnetTimer / CONFIG.magnetDuration) * 100 + "%";
                if (magnetTimer <= 0) {
                    magnetActive = false;
                    document.getElementById('magnetUI').style.display = 'none';
                    gsap.to(magnetAura.material, { opacity: 0, duration: 0.5 });
                }
            }

            for (let i = speedLines.length - 1; i >= 0; i--) {
                speedLines[i].position.z += currentSpeed * 6;
                if (speedLines[i].position.z > 20) { scene.remove(speedLines[i]); speedLines.splice(i, 1); }
            }

            if (!isJumping) {
                const walkSpeed = frameCount * (currentSpeed * 0.5);
                player.leftLeg.position.z = Math.sin(walkSpeed) * 0.5;
                player.rightLeg.position.z = Math.sin(walkSpeed + Math.PI) * 0.5;
                const baseY = antiGravActive ? 1.8 : 1.4;
                const bobAmount = antiGravActive ? 0.2 : 0.1;
                player.position.y = baseY + Math.abs(Math.cos(walkSpeed)) * bobAmount;
            }

            player.position.x = THREE.MathUtils.lerp(player.position.x, targetX, 0.15);
            playerShadow.position.x = player.position.x;
            player.visible = isInvincible ? (frameCount % 10 < 5) : true;

            const speedFactor = (currentSpeed - 0.4) / (CONFIG.maxSpeed * CONFIG.boostMultiplier - 0.4);
            shakeOffsetX = Math.sin(frameCount * 0.5) * (0.01 + (speedFactor * 0.15));
            camera.position.x = THREE.MathUtils.lerp(camera.position.x, player.position.x * 0.5, CONFIG.cameraLerp) + shakeOffsetX;
            camera.lookAt(cameraTarget.lerp(new THREE.Vector3(player.position.x, player.position.y + 0.5, player.position.z), CONFIG.cameraLookLerp));

            tracks.forEach(t => {
                t.position.z += currentSpeed;
                if (t.position.z > 20) t.position.z -= 150;
            });

            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].position.add(particles[i].vel); particles[i].position.z += currentSpeed;
                particles[i].life -= particles[i].decay; particles[i].material.opacity = particles[i].life;
                if (particles[i].life <= 0) { scene.remove(particles[i]); particles.splice(i, 1); }
            }

            updateEntities(obstacles, currentSpeed, true);
            updateCoins(currentSpeed);
            updatePowerups(magnets, speed => activateMagnet(), currentSpeed);
            updatePowerups(boosts, speed => activateBoost(), currentSpeed);
            updateHackChips(currentSpeed);
            updateAlphaStones(currentSpeed);

            if (frameCount % 40 === 0) spawnObstacle();
            if (frameCount % 30 === 0) spawnCoin();
            if (frameCount % 600 === 0) spawnPowerup(magnets, 0x00ffff);
            if (frameCount % 900 === 0) spawnPowerup(boosts, 0xffcc00);
            if (frameCount % 850 === 0) spawnHackChip();
            if (frameCount % 700 === 0) spawnAlphaStone(false);
            if (frameCount % 2500 === 0) spawnAlphaStone(true); // golden variant

            gameScore += currentSpeed;
            document.getElementById('scoreVal').innerText = Math.floor(gameScore).toString().padStart(5, '0');
        }

        function updateCoins(speed) {
            for (let i = coins.length - 1; i >= 0; i--) {
                const coin = coins[i];
                if (magnetActive && coin.position.distanceTo(player.position) < CONFIG.magnetRange) coin.position.lerp(player.position, 0.15);
                coin.position.z += speed; coin.rotation.y += 0.05;
                if (Math.abs(coin.position.z - player.position.z) < 1.2 && Math.abs(coin.position.x - player.position.x) < 1.0) {
                    createBurst(coin.position, 0xffd700); coinsTotal++;
                    document.getElementById('coinVal').innerText = coinsTotal;
                    scene.remove(coin); coins.splice(i, 1);
                } else if (coin.position.z > 15) { scene.remove(coin); coins.splice(i, 1); }
            }
        }

        function updatePowerups(array, callback, speed) {
            for (let i = array.length - 1; i >= 0; i--) {
                const p = array[i]; p.position.z += speed; p.rotation.y += 0.05;
                if (Math.abs(p.position.z - player.position.z) < 1.2 && p.lane === lane) {
                    callback(); scene.remove(p); array.splice(i, 1);
                } else if (p.position.z > 15) { scene.remove(p); array.splice(i, 1); }
            }
        }

        function updateEntities(array, speed, isKill) {
            for (let i = array.length - 1; i >= 0; i--) {
                const ent = array[i]; ent.position.z += speed;
                if (Math.abs(ent.position.z - player.position.z) < 1.2 && ent.lane === lane) {
                    if (isKill && !isInvincible && !(ent.isLow && player.position.y > 2.5)) {
                        handleLifeLoss(); scene.remove(ent); array.splice(i, 1);
                    }
                }
                if (ent.position.z > 15) { scene.remove(ent); array.splice(i, 1); }
            }
        }

        function handleLifeLoss() {
            if (boostActive) return;
            playerLives--;
            policeDistance -= CONFIG.policePenalty;
            if (policeDistance < CONFIG.policeMinDist) policeDistance = CONFIG.policeMinDist;
            isInvincible = true;
            const flash = document.getElementById('flashOverlay');
            flash.style.background = "rgba(255, 0, 0, 0.6)";
            gsap.to(flash, { opacity: 1, duration: 0.05, onComplete: () => gsap.to(flash, { opacity: 0, duration: 0.4 }) });
            shakeCamera(0.8);

            // Play hit sound
            try {
                const hitSound = document.getElementById('hitSound');
                hitSound.currentTime = 0;
                hitSound.play();
            } catch (e) { }

            const heart = document.getElementById('h' + (playerLives + 1));
            if (heart) heart.classList.add('lost');
            if (playerLives <= 0) { handleCollision("CAUGHT!"); } else { setTimeout(() => { isInvincible = false; }, 2000); }
        }

        function spawnObstacle() {
            const l = Math.floor(Math.random() * 3);
            if (l === hackedLane) return;
            const isLow = Math.random() > 0.5;
            const geo = isLow ? new THREE.BoxGeometry(2.5, 1, 1) : new THREE.BoxGeometry(2.5, 5, 2);
            const mat = new THREE.MeshStandardMaterial({ color: isLow ? 0xffaa00 : 0xff0055, emissive: isLow ? 0x221100 : 0x220000 });
            const obs = new THREE.Mesh(geo, mat);
            obs.position.set((l - 1) * CONFIG.laneWidth, isLow ? 0.5 : 2.5, -100);
            obs.lane = l; obs.isLow = isLow;
            scene.add(obs); obstacles.push(obs);
        }

        function spawnCoin() {
            const l = Math.floor(Math.random() * 3);
            const coin = new THREE.Mesh(new THREE.TorusGeometry(0.4, 0.1, 8, 16), new THREE.MeshBasicMaterial({ color: 0xffd700 }));
            coin.position.set((l - 1) * CONFIG.laneWidth, 1.8, -100);
            coin.lane = l; scene.add(coin); coins.push(coin);
        }

        function spawnPowerup(array, color) {
            const l = Math.floor(Math.random() * 3);
            const p = new THREE.Mesh(new THREE.OctahedronGeometry(0.6), new THREE.MeshBasicMaterial({ color: color }));
            p.position.set((l - 1) * CONFIG.laneWidth, 1.8, -100);
            p.lane = l; scene.add(p); array.push(p);
        }

        function spawnHackChip() {
            const l = Math.floor(Math.random() * 3);
            const chip = new THREE.Mesh(new THREE.OctahedronGeometry(0.6), new THREE.MeshStandardMaterial({ color: 0xaa00ff, emissive: 0xaa00ff, emissiveIntensity: 2 }));
            chip.position.set((l - 1) * CONFIG.laneWidth, 1.8, -100);
            chip.lane = l; scene.add(chip); hackChips.push(chip);
        }

        function updateHackChips(speed) {
            for (let i = hackChips.length - 1; i >= 0; i--) {
                const chip = hackChips[i]; chip.position.z += speed; chip.rotation.y += 0.1;
                if (Math.abs(chip.position.z - player.position.z) < 1.2 && chip.lane === lane) {
                    createBurst(chip.position, 0xaa00ff);
                    startHackChallenge();
                    scene.remove(chip); hackChips.splice(i, 1);
                } else if (chip.position.z > 15) { scene.remove(chip); hackChips.splice(i, 1); }
            }
        }

        // ===== ANTI-GRAVITY ALPHA STONE SYSTEM =====

        function spawnAlphaStone(isGolden) {
            const l = Math.floor(Math.random() * 3);
            const stoneGroup = new THREE.Group();

            // Inner core - icosahedron
            const coreGeo = new THREE.IcosahedronGeometry(0.5, 1);
            const coreMat = new THREE.MeshBasicMaterial({
                color: isGolden ? 0xffd700 : 0xff00ff,
                transparent: true,
                opacity: 0.9
            });
            const core = new THREE.Mesh(coreGeo, coreMat);
            stoneGroup.add(core);

            // Outer wireframe ring
            const ringGeo = new THREE.TorusGeometry(0.7, 0.05, 8, 24);
            const ringMat = new THREE.MeshBasicMaterial({
                color: isGolden ? 0xffaa00 : 0x00f2ff,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            stoneGroup.add(ring);

            // Second ring perpendicular
            const ring2 = ring.clone();
            ring2.rotation.x = Math.PI / 2;
            stoneGroup.add(ring2);

            // Point light for glow
            const pointLight = new THREE.PointLight(isGolden ? 0xffd700 : 0xff00ff, 2, 8);
            stoneGroup.add(pointLight);

            stoneGroup.position.set((l - 1) * CONFIG.laneWidth, 2.0, -100);
            stoneGroup.lane = l;
            stoneGroup.isGolden = isGolden;
            stoneGroup.userData = { time: 0 };

            scene.add(stoneGroup);
            alphaStones.push(stoneGroup);
        }

        function updateAlphaStones(speed) {
            for (let i = alphaStones.length - 1; i >= 0; i--) {
                const stone = alphaStones[i];
                stone.position.z += speed;
                stone.userData.time += 0.05;

                // Rainbow pulsing rotation
                stone.children[0].rotation.y += 0.03;
                stone.children[0].rotation.x += 0.02;
                stone.children[1].rotation.z += 0.04;
                stone.children[2].rotation.y += 0.04;

                // Rainbow color cycling for non-golden
                if (!stone.isGolden) {
                    const hue = (stone.userData.time * 0.5) % 1;
                    stone.children[0].material.color.setHSL(hue, 1, 0.5);
                    stone.children[3].color.setHSL(hue, 1, 0.5);
                }

                // Bobbing
                stone.position.y = 2.0 + Math.sin(stone.userData.time * 2) * 0.3;

                // Collection
                if (Math.abs(stone.position.z - player.position.z) < 1.2 && stone.lane === lane) {
                    createBurst(stone.position, stone.isGolden ? 0xffd700 : 0xff00ff);
                    createBurst(stone.position, 0x00f2ff);
                    startAlphaChallenge(stone.isGolden);
                    scene.remove(stone);
                    alphaStones.splice(i, 1);
                } else if (stone.position.z > 15) {
                    scene.remove(stone);
                    alphaStones.splice(i, 1);
                }
            }
        }

        function startAlphaChallenge(isGolden) {
            alphaActive = true;
            alphaIsGolden = isGolden;
            alphaTimeRemaining = ALPHA_TIME_LIMIT;
            alphaClickIndex = 0;
            slowMotionFactor = 0.25; // 75% slower

            // Difficulty scaling: more letters over time
            const letterCount = Math.min(7, ALPHA_BASE_LETTERS + Math.floor(alphaSuccessCount / 3));

            // Generate random unique letters
            const allLetters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
            const selected = [];
            while (selected.length < letterCount) {
                const idx = Math.floor(Math.random() * allLetters.length);
                const letter = allLetters.splice(idx, 1)[0];
                selected.push(letter);
            }

            // Store correct alphabetical order
            alphaCorrectOrder = [...selected].sort();

            // Shuffle for display
            const shuffled = [...selected];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }

            // Build UI
            const container = document.getElementById('alphaLetters');
            container.innerHTML = '';
            shuffled.forEach((letter, idx) => {
                const el = document.createElement('div');
                el.className = 'alpha-letter';
                el.textContent = letter;
                el.dataset.letter = letter;
                el.onclick = () => handleAlphaLetterClick(el);
                container.appendChild(el);
            });

            // Golden badge
            document.getElementById('alphaGoldenBadge').style.display = isGolden ? 'inline-block' : 'none';

            // Combo display
            const comboEl = document.getElementById('alphaCombo');
            comboEl.textContent = alphaComboCount > 0 ? `COMBO √ó${alphaComboCount} // +${alphaComboCount * 500} BONUS` : '';

            document.getElementById('alphaOverlay').style.display = 'flex';
            document.getElementById('alphaPanel').style.animation = 'none';
            void document.getElementById('alphaPanel').offsetWidth; // reflow
            document.getElementById('alphaPanel').style.animation = 'alphaPanelIn 0.4s cubic-bezier(0.16, 1, 0.3, 1)';
        }

        function handleAlphaLetterClick(el) {
            if (!alphaActive) return;
            const letter = el.dataset.letter;

            if (letter === alphaCorrectOrder[alphaClickIndex]) {
                // Correct!
                el.classList.add('correct');
                alphaClickIndex++;

                if (alphaClickIndex >= alphaCorrectOrder.length) {
                    completeAlphaSuccess();
                }
            } else {
                // Wrong!
                el.classList.add('wrong');
                setTimeout(() => completeAlphaFailure(), 400);
            }
        }

        function completeAlphaSuccess() {
            alphaActive = false;
            slowMotionFactor = 1.0;
            document.getElementById('alphaOverlay').style.display = 'none';

            alphaComboCount++;
            alphaSuccessCount++;

            // Combo bonus
            const comboBonus = alphaComboCount * 500;
            gameScore += comboBonus;
            coinsTotal += Math.floor(alphaComboCount * 5);
            document.getElementById('coinVal').innerText = coinsTotal;

            // Massive particle burst
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    const offset = new THREE.Vector3(
                        (Math.random() - 0.5) * 3,
                        Math.random() * 2,
                        (Math.random() - 0.5) * 3
                    );
                    const burstPos = player.position.clone().add(offset);
                    const hue = Math.random();
                    const color = new THREE.Color().setHSL(hue, 1, 0.5);
                    createBurst(burstPos, color.getHex());
                }, i * 100);
            }

            // Flash
            const flash = document.getElementById('flashOverlay');
            flash.style.background = alphaIsGolden ?
                "rgba(255, 215, 0, 0.5)" : "rgba(255, 0, 255, 0.4)";
            gsap.to(flash, {
                opacity: 1, duration: 0.15,
                onComplete: () => gsap.to(flash, { opacity: 0, duration: 0.6 })
            });

            activateAntiGrav(alphaIsGolden);
        }

        function completeAlphaFailure() {
            alphaActive = false;
            slowMotionFactor = 1.0;
            alphaComboCount = 0; // reset combo

            document.getElementById('alphaOverlay').style.display = 'none';

            // Glitch effect on screen
            const flash = document.getElementById('flashOverlay');
            flash.style.background = "rgba(255, 0, 60, 0.6)";
            gsap.to(flash, {
                opacity: 1, duration: 0.05,
                onComplete: () => gsap.to(flash, { opacity: 0, duration: 0.5 })
            });

            // Apply glitch CSS to the renderer canvas
            renderer.domElement.classList.add('glitch-effect');
            setTimeout(() => renderer.domElement.classList.remove('glitch-effect'), 500);

            shakeCamera(1.0);
        }

        function activateAntiGrav(isGolden) {
            antiGravActive = true;
            antiGravDuration = isGolden ? 10000 : 6000;
            antiGravTimer = antiGravDuration;

            document.getElementById('antiGravUI').style.display = 'block';

            // Police pushed back
            policeDistance = Math.min(CONFIG.policeMaxDist, policeDistance + 5);

            // Aura glow
            gsap.to(antiGravAura.material, { opacity: 0.5, duration: 0.4 });
            antiGravAura.material.color.set(isGolden ? 0xffd700 : 0xff00ff);

            // Slight camera FOV shift
            gsap.to(camera, {
                fov: CONFIG.fovBase + 5,
                duration: 0.6,
                onUpdate: () => camera.updateProjectionMatrix()
            });

            // Float player up
            gsap.to(player.position, { y: 1.8, duration: 0.5 });
        }

        function deactivateAntiGrav() {
            antiGravActive = false;
            document.getElementById('antiGravUI').style.display = 'none';

            gsap.to(antiGravAura.material, { opacity: 0, duration: 0.5 });
            gsap.to(camera, {
                fov: CONFIG.fovBase,
                duration: 0.8,
                onUpdate: () => camera.updateProjectionMatrix()
            });

            // Settle player back
            if (!isJumping) gsap.to(player.position, { y: 1.4, duration: 0.5 });

            // Clean trail
            antiGravTrailParticles.forEach(p => scene.remove(p));
            antiGravTrailParticles.length = 0;
        }

        function spawnAntiGravTrailParticle() {
            if (antiGravTrailParticles.length > 60) return;
            const hue = (frameCount * 0.01) % 1;
            const color = new THREE.Color().setHSL(hue, 1, 0.6);
            const geo = new THREE.SphereGeometry(0.08 + Math.random() * 0.08, 6, 6);
            const mat = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            const p = new THREE.Mesh(geo, mat);
            p.position.set(
                player.position.x + (Math.random() - 0.5) * 0.8,
                player.position.y - 0.5 + (Math.random() - 0.5) * 0.5,
                player.position.z + 0.5 + Math.random() * 0.5
            );
            p.life = 1.0;
            p.decay = 0.015 + Math.random() * 0.01;
            scene.add(p);
            antiGravTrailParticles.push(p);
        }

        function updateAntiGravTrail() {
            const currentSpeed = CONFIG.baseSpeed * slowMotionFactor;
            for (let i = antiGravTrailParticles.length - 1; i >= 0; i--) {
                const p = antiGravTrailParticles[i];
                p.position.z += currentSpeed * 1.5;
                p.position.y += 0.01;
                p.life -= p.decay;
                p.material.opacity = p.life * 0.8;
                p.scale.setScalar(p.life);
                if (p.life <= 0) {
                    scene.remove(p);
                    antiGravTrailParticles.splice(i, 1);
                }
            }
        }

        function shakeCamera(intensity) {
            gsap.to(camera.position, {
                x: camera.position.x + (Math.random() - 0.5) * intensity,
                y: camera.position.y + (Math.random() - 0.5) * intensity,
                duration: 0.1, yoyo: true, repeat: 3
            });
        }

        function handleCollision(msg = "GAME OVER") {
            active = false;
            document.getElementById('overlay').style.display = 'flex';
            document.getElementById('titleText').innerText = msg;
            document.getElementById('scoreVal').innerText = "FINAL: " + Math.floor(gameScore);
            document.getElementById('magnetUI').style.display = 'none';
            document.getElementById('boostUI').style.display = 'none';
            document.getElementById('hackOverlay').style.display = 'none';
            document.getElementById('hackTimerUI').style.display = 'none';
            document.getElementById('pauseOverlay').style.display = 'none';
            document.getElementById('alphaOverlay').style.display = 'none';
            document.getElementById('antiGravUI').style.display = 'none';
            deactivateBoost();
            if (antiGravActive) deactivateAntiGrav();
            alphaActive = false;
            slowMotionFactor = 1.0;
            document.getElementById("bgMusic").pause();
        }

        function startGame() {
            document.getElementById("bgMusic").currentTime = 0;
            document.getElementById("bgMusic").play();
            active = true; gameScore = 0; coinsTotal = 0; CONFIG.baseSpeed = 0.4; lane = 1; targetX = 0;
            playerLives = 3; isInvincible = false; magnetActive = false; boostActive = false;
            hackedLane = -1; hackTimer = 0; isPaused = false; hackActive = false;
            antiGravActive = false; antiGravTimer = 0; alphaActive = false; slowMotionFactor = 1.0;
            alphaComboCount = 0; alphaSuccessCount = 0;
            policeDistance = CONFIG.policeMaxDist;
            document.querySelectorAll('.heart').forEach(h => h.classList.remove('lost'));
            document.getElementById('overlay').style.display = 'none';
            document.getElementById('pauseOverlay').style.display = 'none';
            document.getElementById('alphaOverlay').style.display = 'none';
            document.getElementById('antiGravUI').style.display = 'none';
            [obstacles, coins, magnets, boosts, particles, speedLines, hackChips, alphaStones, antiGravTrailParticles].forEach(arr => {
                arr.forEach(o => scene.remove(o)); arr.length = 0;
            });
            trailPoints.length = 0;
            magnetAura.material.opacity = 0; boostWind.material.opacity = 0; hackVisualPlane.material.opacity = 0;
            if (antiGravAura) antiGravAura.material.opacity = 0;
            camera.fov = CONFIG.fovBase; camera.updateProjectionMatrix();
            document.getElementById('coinVal').innerText = "0";
            document.getElementById('flashOverlay').style.opacity = 0;
        }

        function animate() { requestAnimationFrame(animate); update(); renderer.render(scene, camera); }

        window.addEventListener('keydown', (e) => {
            if (hackActive) {
                if (HACK_SYMBOLS_MAP[e.key]) handleHackInput(e.key);
                return;
            }
            if (e.key.toLowerCase() === 'p') togglePause();
            if (isPaused || !active) return;
            if ((e.key === 'a' || e.key === 'ArrowLeft') && lane > 0) { lane--; targetX = (lane - 1) * CONFIG.laneWidth; }
            if ((e.key === 'd' || e.key === 'ArrowRight') && lane < 2) { lane++; targetX = (lane - 1) * CONFIG.laneWidth; }
            if (e.key === ' ' && !isJumping) { isJumping = true; velocityY = CONFIG.jumpForce; }
        });

        // --- SWIPE DETECTION FOR MOBILE ---
        document.addEventListener('touchstart', (e) => {
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
        }, { passive: true });

        document.addEventListener('touchend', (e) => {
            if (!active || isPaused) return;
            const diffX = e.changedTouches[0].screenX - touchStartX;
            const diffY = e.changedTouches[0].screenY - touchStartY;
            const absDiffX = Math.abs(diffX);
            const absDiffY = Math.abs(diffY);
            const minSwipe = 30;

            if (absDiffX > absDiffY && absDiffX > minSwipe) {
                // Horizontal swipe
                if (diffX > 0 && lane < 2) { lane++; targetX = (lane - 1) * CONFIG.laneWidth; }
                else if (diffX < 0 && lane > 0) { lane--; targetX = (lane - 1) * CONFIG.laneWidth; }
            } else if (absDiffY > absDiffX && absDiffY > minSwipe && diffY < 0) {
                // Swipe up = jump
                if (!isJumping) { isJumping = true; velocityY = CONFIG.jumpForce; }
            }
        }, { passive: true });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body>

</html>